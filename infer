#!/usr/bin/env ruby

require 'find'
require 'yaml'
require 'optparse'
require 'optparse/time'
require 'ostruct'
require 'pp'

class String
   def nibble(fixnum=1)
     range_end = self.length - 1
     slice(fixnum..range_end)
   end
end

class Infer

  def initialize(arguments)
    @arguments = arguments
    
    @options = {
      inference_index: 0.1, # 10%
      limit_results: 10,
      unlimited_results: false,
      technique: 'mdfind',

      matchers: {
        graphics: "\.(png|jpeg|jpg|gif|tiff|psd)$",
      },

      handlers: {
        default: "vim $",
        graphics: "open $",
      },
    }

    @content_keywords = []
  end

  def transform_keys_to_symbols(value)
    return value if not value.is_a?(Hash)
    hash = value.inject({}){|memo,(k,v)| memo[k.to_sym] = transform_keys_to_symbols(v); memo}
    return hash
  end

  def load_options(fname)
    fname = File.expand_path(fname)
    yml_options = YAML::load_file(fname) rescue return
    yml_options = transform_keys_to_symbols(yml_options)
    # yml_options = yml_options.inject({}){|memo,(k,v)| memo[k.to_sym] = v; memo}
    @options.merge! yml_options
  end

  def invalid_arg(name)
    print "Options '#{name}' requires an argument.\n"
    exit
  end

  def search search_dir, keywords

    print "Searching #{search_dir}\n\n"

    case @options[:technique]
      when 'grep'
        grep_search search_dir, keywords
      when 'mdfind'
        mdfind_search search_dir, keywords
      when 'locate'
        locate_search search_dir, keywords
      else
        exhaustive_search search_dir, keywords
    end
  end

  def grep_search(keywords)
  end

  def cleanup_path fname
    fname.strip!
  end

  def mdfind_search search_dir, keywords 
    results = []

    base_path = File.expand_path(search_dir) + '/'

    def abs_to_rel str
    end
   
    query = ''

    unless keywords.empty?
      # First we get all files that match any of the filenames (this includes directories)
      query += "(%s)" % keywords.collect{|k| "kMDItemFSName = *%s*" % k}.join(' || ')
    end

    unless @content_keywords.empty?
      query += " && " unless query.empty? 
      query += "(%s)" % @content_keywords.collect{|k| "kMDItemTextContent = '*%s*'cw" % k }.join(' && ')
    end

    pp query
 
    mdfind = ['mdfind', '-onlyin', search_dir, query]
  
    IO.popen mdfind do |out|
      while fname = out.readline rescue nil do
        fname.strip!
        fname.slice! base_path
        # puts fname
        r = rank_file fname
        results << r unless r.nil?
      end
    end

    results
  end

  def exhaustive_search search_dir, keywords
    results = [] 
    Find.find(search_dir) do |fname|
      fname += '/' if File.directory?(fname)
      fname.slice! './'
      r = rank_file fname
      results << r unless r.nil?
    end
    
    results
  end

  def exec_result(fname)
    command = nil

    if @options[:command]
      command = @options[:command]
    else
      @options[:matchers].each do |type, pattern|
        command = @options[:handlers][type] if fname.match(pattern) && @options[:handlers][type] 
      end

      command ||= @options[:handlers][:default]
    end
     
    command = command.gsub /\$/, '"%s"' % fname.gsub('"','\"')
    puts command
    exec command
  end

  def rank_file(fname)
    chars_matched = 0

    ARGV.each do |condition|
      return nil unless fname.include? condition
      chars_matched += condition.length * fname.scan(condition).length
    end

    [fname, chars_matched.to_f / fname.length]
  end

  def run_util

    load_options('~/.infrc') # load from home dir
    load_options('./.infrc') # load from current dir

    opts = OptionParser.new do |opts|
      opts.banner = "Usage: infer [options] keywords"

      opts.separator ""
      opts.separator "Options:"

      opts.on("-s", "--[no-]show", "Show results and never open the inference") do |v|
        @options[:show_only] = v
      end

      opts.on("-n", "--inside [keywords]", "Search inside files") do |v|
        @content_keywords << v
      end

      opts.on("-t", "--technique [mdfind|grep]", "Search technique to use") do |v|
        @options[:technique] = v ? 'mdfind' : ''
      end

      opts.on("-v", "--[no-]verbose", "Verbose output") do |v|
        @options[:verbose] = v
      end

      opts.on(/\/.+/) do |v|
        v.nibble
      end


      # No argument, shows at tail.  This will print an options summary.
      # Try it and see!
      opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
      end

      # Another typical switch to print the version.
      opts.on_tail("--version", "Show version") do
        puts 1.0 
        exit
      end
    end

    opts.parse!(@arguments)
 
#     if ARGV.empty?
#     print <<HELPMESSAGE
#     Usage: infer [options] [keyword]...
# 
#     Recursively searches the current directory based on a set of keywords,
#     launching the best match if it is better than the next by at least #{(@options[:inference_index] * 100).to_i}%.
#     Otherwise it offers a choice.
# 
#     Search algorithm:
#       * All keywords must be matched in the full relative path of a file
#       * At least one of the keywords must match the filename
# 
#     Options:
#       -s    Show results and never open the inference 
#       -a    Show all results, unlimited
#       -l n  Limit number of results by n
#       -c    Command to execute the inference with (filename is $)
#       -i    Search inside files (may be slow, try using different search tool)
#       -(result_number)  Override inference with this result
# 
#       -mdfind  Speedy search with mdfind (OSX only)
# HELPMESSAGE
#     exit
#     end
    # 
    # # Apply command line@options
    # ARGV.each_with_index do |a, i|
    #   opt_list = true if a.match(/^-l/)

    #   a.match /^\\-([a-z]+)/ do |flags|
    #     flags.match
    #     k = match[1]
    #     # v = match[2]

    #     case k
    #       when 's'
    #        @options[:show_only] = true
    #       when 'a'
    #        @options[:unlimited] = true
    #       when 'l'
    #        @options[:limit] = v || ARGV.delete_at(i+1) || invalid_arg('l')
    #       when 'c'
    #        @options[:command] = v || ARGV.delete_at(i+1) || invalid_arg('c') 
    #       when 'm'
    #        @options[:searcher] = 'mdfind'
    #     end

    #     # Remove arg so it's not treated as keyword
    #     ARGV.delete_at(i)
    #   end
    # end

    results = []
    num_kw_chars = ARGV.join.length


    p ARGV

   
    # Use first option as search directory if it is a dir and outside of the CWD
    search_dir = (ARGV[0] if ARGV[0] && ARGV[0].match(/^[\~\.\/]/) && File.directory?(ARGV[0])) || './'

    results = search(search_dir, ARGV)

    results.sort! { |a,b| b[1] <=> a[1] }

    if results.empty?
      puts "Didn't find anything."
      exit
    end

    unless @options[:show_only]
      if results.count == 1 || results[0][1] - results[1][1] > @options[:inference_index]
           exec_result results[0][0]
        exit
      end
    end

    print "\nAmbiguous:\n\n"

    results[0..9].each_with_index do |result, i|
      print "#{i}. "

      10.times do |i|
       print (result[1]/results[0][1]*10) < i ? ' ' : '|'
      end

      print " #{result[0]} \n"
    end

    if results.length > 9
      puts "\n%d more hidden." % results.length
    end

    print  "\nTry refining the search,\nor pick one of the above (0-%d): " % [results.length-1, 9].min 

    sel = Integer(STDIN.gets) rescue nil

    exec_result results[sel][0] unless sel.nil?
  end


  #run_util



  CODES = %w[iso-2022-jp shift_jis euc-jp utf8 binary]
  CODE_ALIASES = { "jis" => "iso-2022-jp", "sjis" => "shift_jis" }

  #
  # Return a structure describing the options.
  #
  def self.parse(args)
    # The options specified on the command line will be collected in *options*.
    # We set default values here.

  end  # parse()

end  # class Infer

# options = Infer.parse(ARGV)
# pp options

if __FILE__ == $0
  trap("SIGINT") { puts " ya"; exit!; }
  i = Infer.new(ARGV)
  i.run_util
end


#!/usr/bin/env ruby

require 'find'
require 'yaml'


$options = {
  inference_index: 0.1, # 10%
  limit_results: 10,
  unlimited_results: false,

  matchers: {
    graphics: "\.(png|jpeg|jpg|gif|tiff|psd)$",
  },

  handlers: {
    default: "vim $",
    graphics: "open $",
  },
}

#take keys of hash and transform those to a symbols
def transform_keys_to_symbols(value)
  return value if not value.is_a?(Hash)
  hash = value.inject({}){|memo,(k,v)| memo[k.to_sym] = transform_keys_to_symbols(v); memo}
  return hash
end

def load_options(fname)
  fname = File.expand_path(fname)
  # Load ~/.infer.yml$options
  yml_options = YAML::load_file(fname) rescue return
  yml_options = transform_keys_to_symbols(yml_options)
  # yml_options = yml_options.inject({}){|memo,(k,v)| memo[k.to_sym] = v; memo}
  $options.merge! yml_options
end

load_options('~/.infer.yml')
load_options('./.infer.yml')


if ARGV.empty?
print <<HEREDOC
Usage: infer [options] [keyword]...

Recursively searches the current directory based on a set of keywords,
launching the best match if it is better than the next by at least #{($options[:inference_index] * 100).to_i}%.
Otherwise it offers a choice

Options:
  -s  Show results and never open the infered file 
  -a  Show all results, unlimited
  -l  Limit number of results by n
  -c  Command to execute the inference with (filename is $)

HEREDOC
exit
end


results = []


def invalid_arg(name)
  print "Options '#{name}' requires an argument.\n"
  exit
end

# Apply command line$options
ARGV.each_with_index do |a, i|
  opt_list = true if a.match(/^-l/)

  a.match /^\-+([a-z])(.+)?/ do |match|
    k = match[1]
    v = match[2]

    case k
    when 's'
       $options[:show_only] = true
      when 'a'
       $options[:unlimited] = true
      when 'l'
       $options[:limit] = v || ARGV.delete_at(i+1) || invalid_arg('l')
      when 'c'
       $options[:command] = v || ARGV.delete_at(i+1) || invalid_arg('c') 
    end

    # Remove arg so it's not treated as keyword
    ARGV.delete_at(i)
  end
end

num_kw_chars = ARGV.join.length

def exec_result(fname)
  command = nil

  if $options[:command]
    command = $options[:command]
  else
    $options[:matchers].each do |type, pattern|
      command = $options[:handlers][type] if fname.match(pattern) && $options[:handlers][type] 
    end

    command ||= $options[:handlers][:default]
  end
  
 
  exec command.gsub /\$/, '"%s"' % fname.gsub('"','\"')
end

def rank_file(fname)
  chars_matched = 0

  ARGV.each do |condition|
    return nil unless fname.include? condition
    chars_matched += condition.length * fname.scan(condition).length if fname.include? condition
  end

  [fname, chars_matched.to_f / fname.length]
end

# Use first option as search directory if it is a dir and outside of the CWD
search_dir = (ARGV[0] if ARGV[0].match(/^[\~\.\/]/) && File.directory?(ARGV[0])) || './'

print "Searching #{search_dir}\n\n"

Find.find(search_dir) do |fname|
  r = rank_file fname
  results << r unless r.nil?
end

results.sort! { |a,b| b[1] <=> a[1] }

if results.empty?
  puts "Didn't find anything."
  exit
end

if results.count == 1 || results[0][1] - results[1][1] > $options[:inference_index]
   exec_result results[0][0]
  exit
end

print "\nAmbiguous:\n\n"

results[0..9].each_with_index do |result, i|
  print "#{i}. "

  10.times do |i|
   print (result[1]/results[0][1]*10) < i ? ' ' : '|'
  end

  print " #{result[0]} \n"
end

if results.length > 9
  puts "\n%d more hidden." % results.length
end

print  "\nTry refining the search,\nor pick one of the above (0-%d): " % [results.length, 9].min 

sel = Integer(STDIN.gets) rescue nil

exec_result results[sel][0] unless sel.nil?

